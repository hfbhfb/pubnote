---
title: slice类型存什么？make和new？slice和数组？扩容规则？
date: 2021-03-25 17:56:14
permalink: /pages/dca66f/
categories:
  - 操作系统级与go进阶
  - golang进阶
tags:
  - 
---



直接看图:

* make 和 new 的 区别
* 在[10]int 中 赋值给slice 后内存状态
* 数组=>slice=>在slice上的append操作,引用了什么底层数组
* 扩容规则



<img src="./minilet/image-20210325175902523.png" alt="image-20210325175902523" style="zoom:70%;" />

<img src="./minilet/image-20210325175752811.png" alt="image-20210325175752811" style="zoom:60%;" />

<img src="./minilet/image-20210325180156243.png" alt="image-20210325180156243" style="zoom:50%;" />



<img src="./minilet/image-20210325180356058.png" alt="image-20210325180356058" style="zoom:50%;" />





<img src="./minilet/image-20210325180611286.png" alt="image-20210325180611286" style="zoom:50%;" />



# 扩容规则

<img src="./minilet/image-20210325181013580.png" alt="image-20210325181013580" style="zoom:50%;" />





* 内存管理模块

  


[图片来源视频](https://www.bilibili.com/video/BV1CV411d7W8)


* 从gin request中读取所有数据: ioutil.ReadAll(c.Request.Body)
  * golang 数据结构slice ioutil.ReadAll(c.Request.Body) 

``` golang
func ReadAll(r Reader) ([]byte, error) {
	b := make([]byte, 0, 512)
	for {
		if len(b) == cap(b) {
			// Add more capacity (let append pick how much).
			b = append(b, 0)[:len(b)]
		}
		n, err := r.Read(b[len(b):cap(b)])
		b = b[:len(b)+n]
		if err != nil {
			if err == EOF {
				err = nil
			}
			return b, err
		}
	}
}
```
